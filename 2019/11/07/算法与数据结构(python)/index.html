<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>算法与数据分析(Python) | JoeSurmt的个站</title>
  
  

  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  

  
  <link rel="shortcut icon" type='image/x-icon' href="../../../../img/favicon.ico">
  

  
    <link rel="stylesheet" href="../../../../style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>JoeSurmt</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="../../../../index.html"
            
            
            id="........index.html">
            <i class='fas fa-rss fa-fw'></i>&nbsp;博文
          </a>
        </li>
      
        <li>
          <a class="nav home" href="../../../../projects/"
            
            
            id="........projects">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;项目
          </a>
        </li>
      
        <li>
          <a class="nav home" href="../../../../friends/"
            
              rel="nofollow"
            
            
            id="........friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home" href="../../../../about/"
            
              rel="nofollow"
            
            
            id="........about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='../../../../index.html' >
        
          JoeSurmt的个站
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="../../../../index.html"
                  
                  
                  id="........index.html">
									<i class='fas fa-grin fa-fw'></i>&nbsp;示例
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="../../../../blog/categories/"
                  
                    rel="nofollow"
                  
                  
                  id="........blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="../../../../blog/tags/"
                  
                    rel="nofollow"
                  
                  
                  id="........blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="../../../../blog/archives/"
                  
                    rel="nofollow"
                  
                  
                  id="........blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="../../../../index.html"
                
                
                id="........index.html">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="../../../../blog/archives/"
                
                  rel="nofollow"
                
                
                id="........blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="../../../../projects/"
                
                
                id="........projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="../../../../friends/"
                
                  rel="nofollow"
                
                
                id="........friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="../../../../about/"
                
                  rel="nofollow"
                
                
                id="........about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
    


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="">
        算法与数据分析(Python)
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://JoeSurmt.github.io" rel="nofollow">
        
          <img src="img/avatar.png">
        
        <p>JoeSurmt</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2019-11-07</p>
  </a>
</div>

          
        
          
            

          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


    <section class="article typo">
      <div class="article-entry" itemprop="articleBody">
        <h1 id="1-概念引入"><a href="#1-概念引入" class="headerlink" title="1. 概念引入"></a>1. 概念引入</h1><h2 id="1-1-算法的提出"><a href="#1-1-算法的提出" class="headerlink" title="1.1 算法的提出"></a><strong>1.1 算法的提出</strong></h2><h3 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a><strong>算法的概念</strong></h3><p>算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般地，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用。</p>
<p><strong>算法是独立存在的一种解决问题的方法和思想。</strong></p>
<p>对于算法而言，实现的语言并不重要，重要的是思想。</p>
<p>算法可以有不同的语言描述实现版本（如C描述、C++描述、Python描述等），我们现在是在用Python语言进行描述实现。</p>
<h3 id="算法的五大特性"><a href="#算法的五大特性" class="headerlink" title="算法的五大特性"></a><strong>算法的五大特性</strong></h3><ol>
<li><strong>输入</strong>: 算法具有0个或多个输入；</li>
<li><strong>输出</strong>: 算法至少有1个或多个输出；</li>
<li><strong>有穷性</strong>: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成；</li>
<li><strong>确定性</strong>：算法中的每一步都有确定的含义，不会出现二义性；</li>
<li><strong>可行性</strong>：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成。</li>
</ol>
<h2 id="1-2-算法效率衡量"><a href="#1-2-算法效率衡量" class="headerlink" title="1.2 算法效率衡量"></a><strong>1.2 算法效率衡量</strong></h2><h3 id="执行时间反应算法效率"><a href="#执行时间反应算法效率" class="headerlink" title="执行时间反应算法效率"></a><strong>执行时间反应算法效率</strong></h3><p>对于同一问题，我们给出了两种解决算法，在两种算法的实现中，我们对程序执行的时间进行了测算，发现两段程序执行的时间相差悬殊（214.583347秒相比于0.182897秒），由此我们可以得出结论：<strong>实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。</strong></p>
<h3 id="单靠时间值绝对可信吗？"><a href="#单靠时间值绝对可信吗？" class="headerlink" title="单靠时间值绝对可信吗？"></a><strong>单靠时间值绝对可信吗？</strong></h3><p>假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214.583347秒快多少。</p>
<p><strong>单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！</strong></p>
<p>程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？</p>
<h3 id="时间复杂度与“大O记法”"><a href="#时间复杂度与“大O记法”" class="headerlink" title="时间复杂度与“大O记法”"></a><strong>时间复杂度与“大O记法”</strong></h3><p>我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。</p>
<p>对于算法的时间效率，我们可以用“大O记法”来表示。</p>
<p><strong>“大O记法”</strong>：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有$f(n)&lt;=c*g(n)$，就说函数g是f的一个渐近函数（忽略常数），记为$f(n)=O(g(n))$。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。</p>
<p><strong>时间复杂度</strong>：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为$T(n)=O(g(n))$，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)。</p>
<h3 id="如何理解“大O记法”"><a href="#如何理解“大O记法”" class="headerlink" title="如何理解“大O记法”"></a><strong>如何理解“大O记法”</strong></h3><p>对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为$3n^2$和$100n^2$属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为$n^2$级。</p>
<h3 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a><strong>最坏时间复杂度</strong></h3><p>分析算法时，存在几种可能的考虑：</p>
<p>算法完成工作最少需要多少基本操作，即<strong>最优时间复杂度</strong></p>
<p>算法完成工作最多需要多少基本操作，即<strong>最坏时间复杂度</strong></p>
<p>算法完成工作平均需要多少基本操作，即<strong>平均时间复杂度</strong></p>
<p>对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。</p>
<p>对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。<br>对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。</p>
<p>因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。**</p>
<h3 id="时间复杂度的几条基本计算规则"><a href="#时间复杂度的几条基本计算规则" class="headerlink" title="时间复杂度的几条基本计算规则"></a><strong>时间复杂度的几条基本计算规则</strong></h3><ol>
<li>基本操作，即只有常数项，认为其时间复杂度为O(1)</li>
<li>顺序结构，时间复杂度按<strong>加法</strong>进行计算</li>
<li>循环结构，时间复杂度按<strong>乘法</strong>进行计算</li>
<li>分支结构，时间复杂度取<strong>最大值</strong></li>
<li>判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略</li>
<li>在没有特殊说明时，我们所分析的算法的时间复杂度都是指<strong>最坏时间复杂度</strong></li>
</ol>
<h2 id="1-3-实际算法分析"><a href="#1-3-实际算法分析" class="headerlink" title="1.3 实际算法分析"></a><strong>1.3 实际算法分析</strong></h2><blockquote>
<p>题目：如果 a+b+c=1000，且a^2+b^2=c^2（a,b,c为自然数），如何求出所有a、b、c可能的组合?</p>
</blockquote>
<ul>
<li>第一次尝试的算法核心部分</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1001</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1001</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1001</span>):</span><br><span class="line">            <span class="keyword">if</span> a**<span class="number">2</span> + b**<span class="number">2</span> == c**<span class="number">2</span> <span class="keyword">and</span> a+b+c == <span class="number">1000</span>:</span><br><span class="line">                print(<span class="string">"a, b, c: %d, %d, %d"</span> % (a, b, c))</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度：</strong></p>
<script type="math/tex; mode=display">T(n) = O(n*n*n) = O(n^3)</script><ul>
<li>第二次尝试的算法核心部分</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1001</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">1001</span>-a):</span><br><span class="line">        c = <span class="number">1000</span> - a - b</span><br><span class="line">        <span class="keyword">if</span> a**<span class="number">2</span> + b**<span class="number">2</span> == c**<span class="number">2</span>:</span><br><span class="line">            print(<span class="string">"a, b, c: %d, %d, %d"</span> % (a, b, c))</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度：</strong></p>
<script type="math/tex; mode=display">T(n) = O(n*n*(1+1)) = O(n*n) = O(n^2)</script><p><strong>由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。</strong></p>
<h2 id="1-4-常见时间复杂度"><a href="#1-4-常见时间复杂度" class="headerlink" title="1.4 常见时间复杂度"></a><strong>1.4 常见时间复杂度</strong></h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">执行次数函数举例</th>
<th style="text-align:center">阶</th>
<th style="text-align:center">非正式术语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$12$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">常数阶</td>
</tr>
<tr>
<td style="text-align:center">$2n+3$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">线性阶</td>
</tr>
<tr>
<td style="text-align:center">$3n^2+2n+1$</td>
<td style="text-align:center">$O(n2)$</td>
<td style="text-align:center">平方阶</td>
</tr>
<tr>
<td style="text-align:center">$5log_2n+20$</td>
<td style="text-align:center">$O(logn)$</td>
<td style="text-align:center">对数阶</td>
</tr>
<tr>
<td style="text-align:center">$2n+3nlog_2n+19$</td>
<td style="text-align:center">$O(nlogn)$</td>
<td style="text-align:center">nlogn阶</td>
</tr>
<tr>
<td style="text-align:center">$6n^3+2n^2+3n+4$</td>
<td style="text-align:center">$O(n^3)$</td>
<td style="text-align:center">立方阶</td>
</tr>
<tr>
<td style="text-align:center">$2^n$</td>
<td style="text-align:center">$O(2^n)$</td>
<td style="text-align:center">指数阶</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注意，经常将$log_2n$（以2为底的对数）简写成logn。</strong></p>
<h3 id="常见时间复杂度之间的关系"><a href="#常见时间复杂度之间的关系" class="headerlink" title="常见时间复杂度之间的关系"></a><strong>常见时间复杂度之间的关系</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/算法效率关系.bmp)</p>
<p>所消耗的时间从小到大:</p>
<script type="math/tex; mode=display">O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)</script><blockquote>
<p>练习： 时间复杂度练习( 参考算法的效率规则判断 )</p>
<p>O(5)</p>
<p>O(2n + 1)</p>
<p>O(n²+ n + 1)</p>
<p>O(3n³+1)</p>
</blockquote>
<h2 id="1-5-Python内置类型性能分析"><a href="#1-5-Python内置类型性能分析" class="headerlink" title="1.5 Python内置类型性能分析"></a><strong>1.5 Python内置类型性能分析</strong></h2><h3 id="timeit模块"><a href="#timeit模块" class="headerlink" title="timeit模块"></a>timeit模块</h3><p>timeit模块可以用来测试一小段Python代码的执行速度。</p>
<p><strong>class timeit.Timer(stmt=’pass’, setup=’pass’, timer=<timer function>)</timer></strong></p>
<p>Timer是测量小段代码执行速度的类。</p>
<p>stmt参数是要测试的代码语句（statment）；</p>
<p>setup参数是运行代码时需要的设置；</p>
<p>timer参数是一个定时器函数，与平台有关。</p>
<p><strong>timeit.Timer.timeit(number=1000000)</strong></p>
<p>Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。</p>
<h3 id="list的操作测试"><a href="#list的操作测试" class="headerlink" title="list的操作测试"></a>list的操作测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">   l = []</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">      l = l + [i]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">   l = []</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">      l.append(i)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">   l = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test4</span><span class="params">()</span>:</span></span><br><span class="line">   l = list(range(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line">t1 = Timer(<span class="string">"test1()"</span>, <span class="string">"from __main__ import test1"</span>)</span><br><span class="line">print(<span class="string">"concat "</span>,t1.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line">t2 = Timer(<span class="string">"test2()"</span>, <span class="string">"from __main__ import test2"</span>)</span><br><span class="line">print(<span class="string">"append "</span>,t2.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line">t3 = Timer(<span class="string">"test3()"</span>, <span class="string">"from __main__ import test3"</span>)</span><br><span class="line">print(<span class="string">"comprehension "</span>,t3.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line">t4 = Timer(<span class="string">"test4()"</span>, <span class="string">"from __main__ import test4"</span>)</span><br><span class="line">print(<span class="string">"list range "</span>,t4.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ('concat ', 1.7890608310699463, 'seconds')</span></span><br><span class="line"><span class="comment"># ('append ', 0.13796091079711914, 'seconds')</span></span><br><span class="line"><span class="comment"># ('comprehension ', 0.05671119689941406, 'seconds')</span></span><br><span class="line"><span class="comment"># ('list range ', 0.014147043228149414, 'seconds')</span></span><br></pre></td></tr></table></figure>
<p> <strong>pop操作测试</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = range(<span class="number">2000000</span>)</span><br><span class="line">pop_zero = Timer(<span class="string">"x.pop(0)"</span>,<span class="string">"from __main__ import x"</span>)</span><br><span class="line">print(<span class="string">"pop_zero "</span>,pop_zero.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line">x = range(<span class="number">2000000</span>)</span><br><span class="line">pop_end = Timer(<span class="string">"x.pop()"</span>,<span class="string">"from __main__ import x"</span>)</span><br><span class="line">print(<span class="string">"pop_end "</span>,pop_end.timeit(number=<span class="number">1000</span>), <span class="string">"seconds"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ('pop_zero ', 1.9101738929748535, 'seconds')</span></span><br><span class="line"><span class="comment"># ('pop_end ', 0.00023603439331054688, 'seconds')</span></span><br></pre></td></tr></table></figure>
<p><strong>测试pop操作：从结果可以看出，pop最后一个元素的效率远远高于pop第一个元素</strong></p>
<blockquote>
<p>可以自行尝试下list的append(value)和insert(0,value),即一个后面插入和一个前面插入？？？</p>
</blockquote>
<h3 id="list内置操作的时间复杂度"><a href="#list内置操作的时间复杂度" class="headerlink" title="list内置操作的时间复杂度"></a>list内置操作的时间复杂度</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/list操作.png)</p>
<h3 id="dict内置操作的时间复杂度"><a href="#dict内置操作的时间复杂度" class="headerlink" title="dict内置操作的时间复杂度"></a>dict内置操作的时间复杂度</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/dict操作.png)</p>
<h2 id="1-6-数据结构"><a href="#1-6-数据结构" class="headerlink" title="1.6 数据结构"></a>1.6 数据结构</h2><blockquote>
<p>我们如何用Python中的类型来保存一个班的学生信息？ 如果想要快速的通过学生姓名获取其信息呢？</p>
</blockquote>
<p>实际上当我们在思考这个问题的时候，我们已经用到了数据结构。列表和字典都可以存储一个班的学生信息，但是想要在列表中获取一名同学的信息时，就要遍历这个列表，其时间复杂度为O(n)，而使用字典存储时，可将学生姓名作为字典的键，学生信息作为值，进而查询时不需要遍历便可快速获取到学生信息，其时间复杂度为O(1)。</p>
<p>我们为了解决问题，需要将数据保存下来，然后根据数据的存储方式来设计算法实现进行处理，那么数据的存储方式不同就会导致需要不同的算法进行处理。我们希望算法解决问题的效率越快越好，于是我们就需要考虑数据究竟如何保存的问题，这就是数据结构。</p>
<p>在上面的问题中我们可以选择Python中的列表或字典来存储学生信息。列表和字典就是Python内建帮我们封装好的两种数据结构。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>数据</strong>是一个抽象的概念，将其进行分类后得到程序设计语言中的基本类型。如：int，float，char等。数据元素之间不是独立的，存在特定的关系，这些关系便是结构。数据结构指数据对象中数据元素之间的关系。</p>
<p>Python给我们提供了很多现成的数据结构类型，这些系统自己定义好的，不需要我们自己去定义的数据结构叫做Python的内置数据结构，比如列表、元组、字典。而有些数据组织方式，Python系统里面没有直接定义，需要我们自己去定义实现这些数据的组织方式，这些数据组织方式称之为Python的扩展数据结构，比如栈，队列等。</p>
<h3 id="算法与数据结构的区别"><a href="#算法与数据结构的区别" class="headerlink" title="算法与数据结构的区别"></a>算法与数据结构的区别</h3><p>数据结构只是静态的描述了数据元素之间的关系。</p>
<p>高效的程序需要在数据结构的基础上设计和选择算法。</p>
<p><strong>程序 = 数据结构 + 算法</strong></p>
<p><strong>总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体</strong></p>
<h3 id="抽象数据类型-Abstract-Data-Type"><a href="#抽象数据类型-Abstract-Data-Type" class="headerlink" title="抽象数据类型(Abstract Data Type)"></a>抽象数据类型(Abstract Data Type)</h3><p>抽象数据类型(ADT)的含义是指一个数学模型以及定义在此数学模型上的一组操作。即把数据类型和数据类型上的运算捆在一起，进行封装。引入抽象数据类型的目的是把数据类型的表示和数据类型上运算的实现与这些数据类型和运算在程序中的引用隔开，使它们相互独立。</p>
<p>最常用的数据运算有五种：</p>
<ul>
<li>插入</li>
<li>删除</li>
<li>修改</li>
<li>查找</li>
<li>排序</li>
</ul>
<h1 id="2-顺序表"><a href="#2-顺序表" class="headerlink" title="2. 顺序表"></a>2. 顺序表</h1><p>在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。</p>
<p>对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。</p>
<p>这样的一组序列元素的组织形式，我们可以将其抽象为<strong>线性表</strong>。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。</p>
<p>根据线性表的实际存储方式，分为两种实现模型：</p>
<ul>
<li><strong>顺序表</strong>，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。</li>
<li><strong>链表</strong>，将元素存放在通过链接构造起来的一系列存储块中。</li>
</ul>
<h2 id="2-1-顺序表的基本形式"><a href="#2-1-顺序表的基本形式" class="headerlink" title="2.1 顺序表的基本形式"></a>2.1 顺序表的基本形式</h2><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/顺序表的两种基本形式.png)</p>
<p>图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址$Loc (e_0)$加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即：</p>
<script type="math/tex; mode=display">Loc(e_i) = Loc(e_0) + c*i</script><p>故，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)。</p>
<p>如果元素的大小不统一，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。<strong>注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。</strong></p>
<p>图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。</p>
<h2 id="2-2-顺序表的结构与实现"><a href="#2-2-顺序表的结构与实现" class="headerlink" title="2.2 顺序表的结构与实现"></a>2.2 顺序表的结构与实现</h2><h3 id="顺序表的结构"><a href="#顺序表的结构" class="headerlink" title="顺序表的结构"></a>顺序表的结构</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python)/顺序表的结构.png" style="zoom:80%;"></p>
<p> 一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的<strong>容量</strong>和当前表中已有的<strong>元素个数</strong>两项。 </p>
<h3 id="顺序表的两种基本实现方式"><a href="#顺序表的两种基本实现方式" class="headerlink" title="顺序表的两种基本实现方式"></a>顺序表的两种基本实现方式</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/顺序表的实现方式.png)</p>
<p>图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。</p>
<p>一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了。</p>
<p>图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。</p>
<h3 id="元素存储区替换"><a href="#元素存储区替换" class="headerlink" title="元素存储区替换"></a>元素存储区替换</h3><p>一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。</p>
<p>分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。</p>
<h3 id="元素存储区扩充"><a href="#元素存储区扩充" class="headerlink" title="元素存储区扩充"></a>元素存储区扩充</h3><p>采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。</p>
<p><strong>扩充的两种策略:</strong></p>
<ul>
<li><p>每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。</p>
<p>特点：节省空间，但是扩充操作频繁，操作次数多。</p>
</li>
<li><p>每次扩充容量加倍，如每次扩充增加一倍存储空间。</p>
<p>特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。</p>
</li>
</ul>
<h2 id="2-3-顺序表的操作"><a href="#2-3-顺序表的操作" class="headerlink" title="2.3 顺序表的操作"></a>2.3 顺序表的操作</h2><h3 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h3><p> 如图所示，为顺序表增加新元素111的三种方式 </p>
<p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/顺序表增加元素.png)</p>
<p>a. 尾端加入元素，时间复杂度为O(1)</p>
<p>b. 非保序的加入元素（不常见），时间复杂度为O(1)</p>
<p>c. 保序的元素加入，时间复杂度为O(n)</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/顺序表删除元素.png)</p>
<p>a. 删除表尾元素，时间复杂度为O(1)</p>
<p>b. 非保序的元素删除（不常见），时间复杂度为O(1)</p>
<p>c. 保序的元素删除，时间复杂度为O(n)</p>
<h2 id="2-4-Python中的顺序表"><a href="#2-4-Python中的顺序表" class="headerlink" title="2.4 Python中的顺序表"></a>2.4 Python中的顺序表</h2><p>Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。</p>
<p>tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。</p>
<h3 id="list的基本实现技术"><a href="#list的基本实现技术" class="headerlink" title="list的基本实现技术"></a>list的基本实现技术</h3><p>Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征：</p>
<ul>
<li><p>基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)；</p>
<p>为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。</p>
</li>
<li><p>允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。</p>
<p>为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。</p>
</li>
</ul>
<p>在Python的官方实现中，<strong>list就是一种采用分离式技术实现的动态顺序表</strong>。这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。</p>
<p>在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。</p>
<h1 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h1><p><strong>为什么需要链表</strong></p>
<p>顺序表的构建需要预先知道数据大小来申请连续的存储空间，而在进行扩充时又需要进行数据的搬迁，所以使用起来并不是很灵活。</p>
<p>链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。</p>
<p><strong>链表的定义</strong></p>
<p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/单向链表图示.png)</p>
<h2 id="3-1-单向链表"><a href="#3-1-单向链表" class="headerlink" title="3.1 单向链表"></a>3.1 单向链表</h2><p>单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/单链表的节点和单链表.png)</p>
<ul>
<li>表元素域elem用来存放具体的数据。</li>
<li>链接域next用来存放下一个节点的位置（python中的标识）</li>
<li>变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。</li>
</ul>
<h3 id="节点实现"><a href="#节点实现" class="headerlink" title="节点实现"></a>节点实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单链表的结点"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="comment"># _item存放数据元素</span></span><br><span class="line">        self.item = item</span><br><span class="line">        <span class="comment"># _next是下一个节点的标识</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h3><ul>
<li>is_empty() 链表是否为空</li>
<li>length() 链表长度</li>
<li>travel() 遍历整个链表</li>
<li>add(item) 链表头部添加元素</li>
<li>append(item) 链表尾部添加元素</li>
<li>insert(pos, item) 指定位置添加元素</li>
<li>remove(item) 删除节点</li>
<li>search(item) 查找节点是否存在</li>
</ul>
<h3 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""链表长度"""</span></span><br><span class="line">        <span class="comment"># cur初始时指向头节点</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 尾节点指向None，当未到达尾部时</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将cur后移一个节点</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""遍历链表"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">print</span> cur.item,</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">print</span> <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p> <strong>头部添加元素</strong><br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/单链表表头插入元素.png)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="string">"""头部添加元素"""</span></span><br><span class="line">    <span class="comment"># 先创建一个保存item值的节点</span></span><br><span class="line">    node = SingleNode(item)</span><br><span class="line">    <span class="comment"># 将新节点的链接域next指向头节点，即_head指向的位置</span></span><br><span class="line">    node.next = self._head</span><br><span class="line">    <span class="comment"># 将链表的头_head指向新节点</span></span><br><span class="line">    self._head = node</span><br></pre></td></tr></table></figure>
<p> <strong>尾部添加元素</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="string">"""尾部添加元素"""</span></span><br><span class="line">    node = SingleNode(item)</span><br><span class="line">    <span class="comment"># 先判断链表是否为空，若是空链表，则将_head指向新节点</span></span><br><span class="line">    <span class="keyword">if</span> self.is_empty():</span><br><span class="line">        self._head = node</span><br><span class="line">    <span class="comment"># 若不为空，则找到尾部，将尾节点的next指向新节点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = node</span><br></pre></td></tr></table></figure>
<p> <strong>指定位置添加元素</strong><br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/单链表指定位置添加元素.png)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">    <span class="string">"""指定位置添加元素"""</span></span><br><span class="line">    <span class="comment"># 若指定位置pos为第一个元素之前，则执行头部插入</span></span><br><span class="line">    <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">        self.add(item)</span><br><span class="line">    <span class="comment"># 若指定位置超过链表尾部，则执行尾部插入</span></span><br><span class="line">    <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">        self.append(item)</span><br><span class="line">    <span class="comment"># 找到指定位置</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = SingleNode(item)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置</span></span><br><span class="line">        pre = self._head</span><br><span class="line">        <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">        <span class="comment"># 先将新节点node的next指向插入位置的节点</span></span><br><span class="line">        node.next = pre.next</span><br><span class="line">        <span class="comment"># 将插入位置的前一个节点的next指向新节点</span></span><br><span class="line">        pre.next = node</span><br></pre></td></tr></table></figure>
<p> <strong>删除节点</strong><br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/单链表删除节点.png)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,item)</span>:</span></span><br><span class="line">    <span class="string">"""删除节点"""</span></span><br><span class="line">    cur = self._head</span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 找到了指定元素</span></span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="comment"># 如果第一个就是删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                <span class="comment"># 将头指针指向头节点的后一个节点</span></span><br><span class="line">                self._head = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将删除位置前一个节点的next指向删除位置的后一个节点</span></span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 继续按链表后移节点</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.next</span><br></pre></td></tr></table></figure>
<p> <strong>查找节点是否存在</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,item)</span>:</span></span><br><span class="line">    <span class="string">"""链表查找节点是否存在，并返回True或者False"""</span></span><br><span class="line">    cur = self._head</span><br><span class="line">    <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        cur = cur.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p> <strong>测试</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ll = SingleLinkList()</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="keyword">print</span> ll.search(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">print</span> ll.search(<span class="number">5</span>)</span><br><span class="line">    ll.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<h3 id="链表与顺序表的对比"><a href="#链表与顺序表的对比" class="headerlink" title="链表与顺序表的对比"></a>链表与顺序表的对比</h3><p>链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。</p>
<p>链表与顺序表的各种操作复杂度如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">链表</th>
<th style="text-align:center">顺序表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">访问元素</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">在头部插入/删除</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(n)</td>
</tr>
<tr>
<td style="text-align:center">在尾部插入/删除</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">在中间插入/删除</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n)</td>
</tr>
</tbody>
</table>
</div>
<p>注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。</p>
<h2 id="3-2-单向循环链表"><a href="#3-2-单向循环链表" class="headerlink" title="3.2 单向循环链表"></a>3.2 单向循环链表</h2><p> 单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/单向循环链表.png)</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li>is_empty() 判断链表是否为空</li>
<li>length() 返回链表的长度</li>
<li>travel() 遍历</li>
<li>add(item) 在头部添加一个节点</li>
<li>append(item) 在尾部添加一个节点</li>
<li>insert(pos, item) 在指定位置pos添加节点</li>
<li>remove(item) 删除一个节点</li>
<li>search(item) 查找节点是否存在</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""节点"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinCycLinkedlist</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单向循环链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回链表的长度"""</span></span><br><span class="line">        <span class="comment"># 如果链表为空，返回长度0</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""遍历链表"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">print</span> cur.item,</span><br><span class="line">        <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">print</span> cur.item,</span><br><span class="line">        <span class="keyword">print</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""头部添加节点"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#添加的节点指向_head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="comment"># 移到链表尾部，将尾部节点的next指向node</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="comment">#_head指向添加node的</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""尾部添加节点"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 移到链表尾部</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 将尾节点指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="comment"># 将node指向头节点_head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="string">"""在指定位置添加节点"""</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""删除一个节点"""</span></span><br><span class="line">        <span class="comment"># 若链表为空，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 将cur指向头节点</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 若头节点的元素就是要查找的元素item</span></span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="comment"># 如果链表不止一个节点</span></span><br><span class="line">            <span class="keyword">if</span> cur.next != self._head:</span><br><span class="line">                <span class="comment"># 先找到尾节点，将尾节点的next指向第二个节点</span></span><br><span class="line">                <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                <span class="comment"># cur指向了尾节点</span></span><br><span class="line">                cur.next = self._head.next</span><br><span class="line">                self._head = self._head.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 链表只有一个节点</span></span><br><span class="line">                self._head = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self._head</span><br><span class="line">            <span class="comment"># 第一个节点不是要删除的</span></span><br><span class="line">            <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">                <span class="comment"># 找到了要删除的元素</span></span><br><span class="line">                <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                    <span class="comment"># 删除</span></span><br><span class="line">                    pre.next = cur.next</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre = cur</span><br><span class="line">                    cur = cur.next</span><br><span class="line">            <span class="comment"># cur 指向尾节点</span></span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="comment"># 尾部删除</span></span><br><span class="line">                pre.next = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""查找节点是否存在"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ll = SinCycLinkedlist()</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    ll.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    ll.insert(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="keyword">print</span> ll.search(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">print</span> ll.search(<span class="number">7</span>)</span><br><span class="line">    ll.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<h2 id="3-3-双向链表"><a href="#3-3-双向链表" class="headerlink" title="3.3 双向链表"></a>3.3 双向链表</h2><p> 一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/双向链表.png)</p>
<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul>
<li>is_empty() 链表是否为空</li>
<li>length() 链表长度</li>
<li>travel() 遍历链表</li>
<li>add(item) 链表头部添加</li>
<li>append(item) 链表尾部添加</li>
<li>insert(pos, item) 指定位置添加</li>
<li>remove(item) 删除节点</li>
<li>search(item) 查找节点是否存在</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""双向链表节点"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""双向链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回链表的长度"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""遍历链表"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">print</span> cur.item,</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">print</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""头部插入元素"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将node的next指向_head的头节点</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="comment"># 将_head的头节点的prev指向node</span></span><br><span class="line">            self._head.prev = node</span><br><span class="line">            <span class="comment"># 将_head 指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""尾部插入元素"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="comment"># 如果是空链表，将_head指向node</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 移动到链表尾部</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 将尾节点cur的next指向node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="comment"># 将node的prev指向cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""查找元素是否存在"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>指定位置插入节点</strong><br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/双向链表指定位置插入元素.png)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">    <span class="string">"""在指定位置添加节点"""</span></span><br><span class="line">    <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">        self.add(item)</span><br><span class="line">    <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">        self.append(item)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node = Node(item)</span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">        <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="comment"># 将node的prev指向cur</span></span><br><span class="line">        node.prev = cur</span><br><span class="line">        <span class="comment"># 将node的next指向cur的下一个节点</span></span><br><span class="line">        node.next = cur.next</span><br><span class="line">        <span class="comment"># 将cur的下一个节点的prev指向node</span></span><br><span class="line">        cur.next.prev = node</span><br><span class="line">        <span class="comment"># 将cur的next指向node</span></span><br><span class="line">        cur.next = node</span><br></pre></td></tr></table></figure>
<p> <strong>删除元素</strong><br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/双向链表删除节点.png)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="string">"""删除元素"""</span></span><br><span class="line">    <span class="keyword">if</span> self.is_empty():</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">if</span> cur.item == item:</span><br><span class="line">            <span class="comment"># 如果首节点的元素即是要删除的元素</span></span><br><span class="line">            <span class="keyword">if</span> cur.next == <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 如果链表只有这一个节点</span></span><br><span class="line">                self._head = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 将第二个节点的prev设置为None</span></span><br><span class="line">                cur.next.prev = <span class="literal">None</span></span><br><span class="line">                <span class="comment"># 将_head指向第二个节点</span></span><br><span class="line">                self._head = cur.next</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="comment"># 将cur的前一个节点的next指向cur的后一个节点</span></span><br><span class="line">                cur.prev.next = cur.next</span><br><span class="line">                <span class="comment"># 将cur的后一个节点的prev指向cur的前一个节点</span></span><br><span class="line">                cur.next.prev = cur.prev</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            cur = cur.next</span><br></pre></td></tr></table></figure>
<p> <strong>测试</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ll = DLinkList()</span><br><span class="line">    ll.add(<span class="number">1</span>)</span><br><span class="line">    ll.add(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.insert(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">    ll.insert(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    ll.insert(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br><span class="line">    <span class="keyword">print</span> ll.search(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">print</span> ll.search(<span class="number">4</span>)</span><br><span class="line">    ll.remove(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length:"</span>,ll.length()</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>
<h1 id="4-栈"><a href="#4-栈" class="headerlink" title="4.栈"></a>4.栈</h1><p>栈（stack），有些地方称为堆栈，是一种容器，可存入数据元素、访问元素、删除元素，它的特点在于只能允许在容器的一端（称为栈顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。没有了位置概念，保证任何时候可以访问、删除的元素都是此前最后存入的那个元素，确定了一种默认的访问顺序。</p>
<p>由于栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/栈.png)</p>
<h2 id="4-1栈结构实现"><a href="#4-1栈结构实现" class="headerlink" title="4.1栈结构实现"></a>4.1栈结构实现</h2><p>栈可以用顺序表实现，也可以用链表实现。</p>
<h3 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h3><ul>
<li>Stack() 创建一个新的空栈</li>
<li>push(item) 添加一个新的元素item到栈顶</li>
<li>pop() 弹出栈顶元素</li>
<li>peek() 返回栈顶元素</li>
<li>is_empty() 判断栈是否为空</li>
<li>size() 返回栈的元素个数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""栈"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">         self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""加入元素"""</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""弹出元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈顶元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.items[len(self.items)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈的大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    stack = Stack()</span><br><span class="line">    stack.push(<span class="string">"hello"</span>)</span><br><span class="line">    stack.push(<span class="string">"world"</span>)</span><br><span class="line">    stack.push(<span class="string">"itcast"</span>)</span><br><span class="line">    <span class="keyword">print</span> stack.size()</span><br><span class="line">    <span class="keyword">print</span> stack.peek()</span><br><span class="line">    <span class="keyword">print</span> stack.pop()</span><br><span class="line">    <span class="keyword">print</span> stack.pop()</span><br><span class="line">    <span class="keyword">print</span> stack.pop()</span><br></pre></td></tr></table></figure>
<p> 执行过程如下：<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/stack演示.gif)</p>
<h1 id="5-队列"><a href="#5-队列" class="headerlink" title="5. 队列"></a>5. 队列</h1><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。队列不允许在中间部位进行操作！假设队列是q=（a1，a2，……，an），那么a1就是队头元素，而an是队尾元素。这样我们就可以删除时，总是从a1开始，而插入时，总是在队列最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后。<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/队列模型.png)<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/排队.jpeg)</p>
<h2 id="5-1-队列的实现"><a href="#5-1-队列的实现" class="headerlink" title="5.1 队列的实现"></a>5.1 队列的实现</h2><p>同栈一样，队列也可以用顺序表或者链表实现。</p>
<h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h3><ul>
<li>Queue() 创建一个空的队列</li>
<li>enqueue(item) 往队列中添加一个item元素</li>
<li>dequeue() 从队列头部删除一个元素</li>
<li>is_empty() 判断一个队列是否为空</li>
<li>size() 返回队列的大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""队列"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""进队列"""</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""出队列"""</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    q.enqueue(<span class="string">"hello"</span>)</span><br><span class="line">    q.enqueue(<span class="string">"world"</span>)</span><br><span class="line">    q.enqueue(<span class="string">"itcast"</span>)</span><br><span class="line">    <span class="keyword">print</span> q.size()</span><br><span class="line">    <span class="keyword">print</span> q.dequeue()</span><br><span class="line">    <span class="keyword">print</span> q.dequeue()</span><br><span class="line">    <span class="keyword">print</span> q.dequeue()</span><br></pre></td></tr></table></figure>
<h2 id="5-2-双端队列"><a href="#5-2-双端队列" class="headerlink" title="5.2 双端队列"></a>5.2 双端队列</h2><p>双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构。</p>
<p>双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/双端队列.png)</p>
<h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h3><ul>
<li>Deque() 创建一个空的双端队列</li>
<li>add_front(item) 从队头加入一个item元素</li>
<li>add_rear(item) 从队尾加入一个item元素</li>
<li>remove_front() 从队头删除一个item元素</li>
<li>remove_rear() 从队尾删除一个item元素</li>
<li>is_empty() 判断双端队列是否为空</li>
<li>size() 返回队列的大小</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""双端队列"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断队列是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_front</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""在队头添加元素"""</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>,item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_rear</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""在队尾添加元素"""</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从队头删除元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_rear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从队尾删除元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队列大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    deque = Deque()</span><br><span class="line">    deque.add_front(<span class="number">1</span>)</span><br><span class="line">    deque.add_front(<span class="number">2</span>)</span><br><span class="line">    deque.add_rear(<span class="number">3</span>)</span><br><span class="line">    deque.add_rear(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> deque.size()</span><br><span class="line">    <span class="keyword">print</span> deque.remove_front()</span><br><span class="line">    <span class="keyword">print</span> deque.remove_front()</span><br><span class="line">    <span class="keyword">print</span> deque.remove_rear()</span><br><span class="line">    <span class="keyword">print</span> deque.remove_rear()</span><br></pre></td></tr></table></figure>
<h1 id="6-排序与搜索"><a href="#6-排序与搜索" class="headerlink" title="6. 排序与搜索"></a>6. 排序与搜索</h1><p>排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。</p>
<p><strong>排序算法的稳定性</strong></p>
<p><strong>稳定性</strong>：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。</p>
<p>当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(4, 1)  (3, 1)  (3, 7)（5, 6）</span><br></pre></td></tr></table></figure>
<p>在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(3, 1)  (3, 7)  (4, 1)  (5, 6)  （维持次序）</span><br><span class="line">(3, 7)  (3, 1)  (4, 1)  (5, 6)  （次序被改变）</span><br></pre></td></tr></table></figure>
<p>不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。作这件事情的一个方式是人工扩充键值的比较，如此在其他方面相同键值的两个对象间之比较，（比如上面的比较中加入第二个标准：第二个键值的大小）就会被决定使用在原先数据次序中的条目，当作一个同分决赛。然而，要记住这种次序通常牵涉到额外的空间负担。</p>
<h2 id="6-1-冒泡排序"><a href="#6-1-冒泡排序" class="headerlink" title="6.1 冒泡排序"></a>6.1 冒泡排序</h2><p><strong>冒泡排序</strong>（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>冒泡排序算法的运作如下：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h3 id="冒泡排序的分析"><a href="#冒泡排序的分析" class="headerlink" title="冒泡排序的分析"></a>冒泡排序的分析</h3><p>交换过程图示(第一次)：<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/bubblesort.jpg)</p>
<p> 那么我们需要进行n-1次冒泡过程，每次对应的比较次数如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/compare.bmp)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(alist)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># j表示每次遍历需要比较的次数，是逐渐减小的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j):</span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>], alist[i]</span><br><span class="line"></span><br><span class="line">li = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">bubble_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最优时间复杂度：$O(n)$ （表示遍历一次发现没有任何可以交换的元素，排序结束。）</li>
<li>最坏时间复杂度：$O(n^2)$</li>
<li>稳定性：稳定</li>
</ul>
<h3 id="冒泡排序的演示"><a href="#冒泡排序的演示" class="headerlink" title="冒泡排序的演示"></a>冒泡排序的演示</h3><p>效果：<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/bubble.gif)</p>
<h2 id="6-2-选择排序"><a href="#6-2-选择排序" class="headerlink" title="6.2 选择排序"></a>6.2 选择排序</h2><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h3 id="选择排序分析"><a href="#选择排序分析" class="headerlink" title="选择排序分析"></a>选择排序分析</h3><p>排序过程：<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/selectionsort.jpg)<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/Selection-Sort-Animation.gif)</p>
<p> 红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># 需要进行n-1次选择操作</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 记录最小位置</span></span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="comment"># 从i+1位置到末尾选择出最小数据</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="comment"># 如果选择出的数据不在正确位置，进行交换</span></span><br><span class="line">        <span class="keyword">if</span> min_index != i:</span><br><span class="line">            alist[i], alist[min_index] = alist[min_index], alist[i]</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">226</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">selection_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最优时间复杂度：$O(n^2)$</li>
<li>最坏时间复杂度：$O(n^2)$</li>
<li>稳定性：不稳定（考虑升序每次选择最大的情况）</li>
</ul>
<h3 id="选择排序演示"><a href="#选择排序演示" class="headerlink" title="选择排序演示"></a>选择排序演示</h3><p>效果：<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/selection.gif)</p>
<h2 id="6-3-插入排序"><a href="#6-3-插入排序" class="headerlink" title="6.3 插入排序"></a>6.3 插入排序</h2><p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h3 id="插入排序分析"><a href="#插入排序分析" class="headerlink" title="插入排序分析"></a>插入排序分析</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/insert.png)</p>
<p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/Insertion-sort-example.gif)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="comment"># 从第二个位置，即下标为1的元素开始向前插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(alist)):</span><br><span class="line">        <span class="comment"># 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[j<span class="number">-1</span>]:</span><br><span class="line">                alist[j], alist[j<span class="number">-1</span>] = alist[j<span class="number">-1</span>], alist[j]</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">insert_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最优时间复杂度：$O(n)$（升序排列，序列已经处于升序状态）</li>
<li>最坏时间复杂度：$O(n^2)$</li>
<li>稳定性：稳定</li>
</ul>
<h3 id="插入排序演示"><a href="#插入排序演示" class="headerlink" title="插入排序演示"></a>插入排序演示</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/insert.gif)</p>
<h2 id="6-4-快速排序"><a href="#6-4-快速排序" class="headerlink" title="6.4 快速排序"></a>6.4 快速排序</h2><p>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>步骤为：</p>
<ol>
<li>从数列中挑出一个元素，称为”基准”（pivot），</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<h3 id="快速排序的分析"><a href="#快速排序的分析" class="headerlink" title="快速排序的分析"></a>快速排序的分析</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/快速排序.jpg)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(alist, start, end)</span>:</span></span><br><span class="line">    <span class="string">"""快速排序"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归的退出条件</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设定起始元素为要寻找位置的基准元素</span></span><br><span class="line">    mid = alist[start]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># low为序列左边的由左向右移动的游标</span></span><br><span class="line">    low = start</span><br><span class="line"></span><br><span class="line">    <span class="comment"># high为序列右边的由右向左移动的游标</span></span><br><span class="line">    high = end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="comment"># 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[high] &gt;= mid:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将high指向的元素放到low的位置上</span></span><br><span class="line">        alist[low] = alist[high]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果low与high未重合，low指向的元素比基准元素小，则low向右移动</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> alist[low] &lt; mid:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将low指向的元素放到high的位置上</span></span><br><span class="line">        alist[high] = alist[low]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 退出循环后，low与high重合，此时所指位置为基准元素的正确位置</span></span><br><span class="line">    <span class="comment"># 将基准元素放到该位置</span></span><br><span class="line">    alist[low] = mid</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对基准元素左边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, start, low<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对基准元素右边的子序列进行快速排序</span></span><br><span class="line">    quick_sort(alist, low+<span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">quick_sort(alist,<span class="number">0</span>,len(alist)<span class="number">-1</span>)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最优时间复杂度：$O(nlogn)$</li>
<li>最坏时间复杂度：$O(n^2)$</li>
<li>稳定性：不稳定</li>
</ul>
<p>从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。</p>
<p>在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。</p>
<h3 id="快速排序演示"><a href="#快速排序演示" class="headerlink" title="快速排序演示"></a>快速排序演示</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/quicksort.gif)</p>
<h2 id="6-5-希尔排序"><a href="#6-5-希尔排序" class="headerlink" title="6.5 希尔排序"></a>6.5 希尔排序</h2><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h3 id="希尔排序过程"><a href="#希尔排序过程" class="headerlink" title="希尔排序过程"></a>希尔排序过程</h3><p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>
<p>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样(竖着的元素是步长组成)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>然后我们对每列进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<p>排序之后变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure>
<p>最后以1步长进行排序（此时就是简单的插入排序了）</p>
<h3 id="希尔排序的分析"><a href="#希尔排序的分析" class="headerlink" title="希尔排序的分析"></a>希尔排序的分析</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/shellsort.png)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># 初始步长</span></span><br><span class="line">    gap = n / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 按步长进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j&gt;=gap <span class="keyword">and</span> alist[j-gap] &gt; alist[j]:</span><br><span class="line">                alist[j-gap], alist[j] = alist[j], alist[j-gap]</span><br><span class="line">                j -= gap</span><br><span class="line">        <span class="comment"># 得到新的步长</span></span><br><span class="line">        gap = gap / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">shell_sort(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最优时间复杂度：根据步长序列的不同而不同</li>
<li>最坏时间复杂度：$O(n^2)$</li>
<li>稳定想：不稳定</li>
</ul>
<h3 id="希尔排序演示"><a href="#希尔排序演示" class="headerlink" title="希尔排序演示"></a>希尔排序演示</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/shellsort.gif)</p>
<h2 id="6-6-归并排序"><a href="#6-6-归并排序" class="headerlink" title="6.6 归并排序"></a>6.6 归并排序</h2><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p>
<p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p>
<h3 id="归并排序的分析"><a href="#归并排序的分析" class="headerlink" title="归并排序的分析"></a>归并排序的分析</h3><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/Merge-sort-example.gif)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(alist) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> alist</span><br><span class="line">    <span class="comment"># 二分分解</span></span><br><span class="line">    num = len(alist)/<span class="number">2</span></span><br><span class="line">    left = merge_sort(alist[:num])</span><br><span class="line">    right = merge_sort(alist[num:])</span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    <span class="string">'''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''</span></span><br><span class="line">    <span class="comment">#left与right的下标指针</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> l&lt;len(left) <span class="keyword">and</span> r&lt;len(right):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt; right[r]:</span><br><span class="line">            result.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    result += left[l:]</span><br><span class="line">    result += right[r:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">alist = [<span class="number">54</span>,<span class="number">26</span>,<span class="number">93</span>,<span class="number">17</span>,<span class="number">77</span>,<span class="number">31</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">20</span>]</span><br><span class="line">sorted_alist = mergeSort(alist)</span><br><span class="line">print(sorted_alist)</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最优时间复杂度：$O(nlogn)$</li>
<li>最坏时间复杂度：$O(nlogn)$</li>
<li>稳定性：稳定</li>
</ul>
<h2 id="6-7-常见排序算法效率比较"><a href="#6-7-常见排序算法效率比较" class="headerlink" title="6.7 常见排序算法效率比较"></a>6.7 常见排序算法效率比较</h2><p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/排序比较.jpg)</p>
<h2 id="6-8-搜索"><a href="#6-8-搜索" class="headerlink" title="6.8 搜索"></a>6.8 搜索</h2><p>搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找</p>
<h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/Binary_search_into_array.png)</p>
<h3 id="二分法查找实现"><a href="#二分法查找实现" class="headerlink" title="二分法查找实现"></a>二分法查找实现</h3><p><strong>（非递归实现）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(alist, item)</span>:</span></span><br><span class="line">      first = <span class="number">0</span></span><br><span class="line">      last = len(alist)<span class="number">-1</span></span><br><span class="line">      <span class="keyword">while</span> first&lt;=last:</span><br><span class="line">          midpoint = (first + last)/<span class="number">2</span></span><br><span class="line">          <span class="keyword">if</span> alist[midpoint] == item:</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">          <span class="keyword">elif</span> item &lt; alist[midpoint]:</span><br><span class="line">              last = midpoint<span class="number">-1</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              first = midpoint+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</span><br><span class="line">print(binary_search(testlist, <span class="number">3</span>))</span><br><span class="line">print(binary_search(testlist, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>
<p><strong>（递归实现）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(alist, item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(alist) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        midpoint = len(alist)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> alist[midpoint]==item:</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">if</span> item&lt;alist[midpoint]:</span><br><span class="line">            <span class="keyword">return</span> binary_search(alist[:midpoint],item)</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> binary_search(alist[midpoint+<span class="number">1</span>:],item)</span><br><span class="line"></span><br><span class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</span><br><span class="line">print(binary_search(testlist, <span class="number">3</span>))</span><br><span class="line">print(binary_search(testlist, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>最优时间复杂度：$O(1)$</li>
<li>最坏时间复杂度：$O(logn)$</li>
</ul>
<h1 id="7-树与树算法"><a href="#7-树与树算法" class="headerlink" title="7. 树与树算法"></a>7. 树与树算法</h1><p><strong>树的概念</strong></p>
<p>树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ul>
<p>比如说：<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/tree.png)<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/Treedatastructure.png)</p>
<p><strong>树的术语</strong></p>
<ul>
<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li>
<li><strong>树的度</strong>：一棵树中，最大的节点的度称为树的度；</li>
<li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li>
<li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点或子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的<strong>层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>树的<strong>高度</strong>或<strong>深度</strong>：树中节点的最大层次；</li>
<li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li><strong>森林</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ul>
<p><strong>树的种类</strong></p>
<ul>
<li><p><strong>无序树</strong>：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；</p>
</li>
<li><p>有序树</p>
<p>：树中任意节点的子节点之间有顺序关系，这种树称为有序树；</p>
<ul>
<li>二叉树：每个节点最多含有两个子树的树称为二叉树；<ul>
<li><strong>完全二叉树</strong>：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中<strong>满二叉树</strong>的定义是所有叶节点都在最底层的完全二叉树;</li>
<li><strong>平衡二叉树</strong>（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li><strong>排序二叉树</strong>（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；</li>
</ul>
</li>
<li><strong>霍夫曼树</strong>（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li><strong>B树</strong>：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。</li>
</ul>
</li>
</ul>
<p><strong>树的存储与表示</strong></p>
<p><strong>顺序存储：</strong>将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/树的顺序存储.png)</p>
<p> <strong>链式存储：</strong><br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/树的链式存储.png)</p>
<p>由于对节点的个数无法掌握，常见树的存储表示都转换成二叉树进行处理，子节点个数最多为2。</p>
<p><strong>常见的一些树的应用场景</strong></p>
<p>1.xml，html等，那么编写这些东西的解析器的时候，不可避免用到树</p>
<p>2.路由协议就是使用了树的算法</p>
<p>3.mysql数据库索引</p>
<p>4.文件系统的目录结构</p>
<p>5.所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/网页结构.jpg)</p>
<h2 id="7-1-二叉树"><a href="#7-1-二叉树" class="headerlink" title="7.1 二叉树"></a>7.1 二叉树</h2><h3 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h3><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。</p>
<h3 id="二叉树的性质-特性"><a href="#二叉树的性质-特性" class="headerlink" title="二叉树的性质(特性)"></a>二叉树的性质(特性)</h3><p><strong>性质1:</strong> 在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）</p>
<p><strong>性质2:</strong> 深度为k的二叉树至多有2^k - 1个结点（k&gt;0）</p>
<p><strong>性质3:</strong> 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;</p>
<p><strong>性质4:</strong>具有n个结点的完全二叉树的深度必为 log2(n+1)</p>
<p><strong>性质5:</strong>对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）</p>
<p> (1)<strong>完全二叉树</strong>——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/完全二叉树.png)</p>
<p> (2)<strong>满二叉树</strong>——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/满二叉树.png)</p>
<h3 id="二叉树的节点表示以及树的创建"><a href="#二叉树的节点表示以及树的创建" class="headerlink" title="二叉树的节点表示以及树的创建"></a>二叉树的节点表示以及树的创建</h3><p>通过使用Node类中定义三个属性，分别为elem本身的值，还有lchild左孩子和rchild右孩子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""节点类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elem=<span class="number">-1</span>, lchild=None, rchild=None)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.lchild = lchild</span><br><span class="line">        self.rchild = rchild</span><br></pre></td></tr></table></figure>
<p> 树的创建,创建一个树的类，并给一个root根节点，一开始为空，随后添加节点 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""树类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root=None)</span>:</span></span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        <span class="string">"""为树添加节点"""</span></span><br><span class="line">        node = Node(elem)</span><br><span class="line">        <span class="comment">#如果树是空的，则对根节点赋值</span></span><br><span class="line">        <span class="keyword">if</span> self.root == <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue = []</span><br><span class="line">            queue.append(self.root)</span><br><span class="line">            <span class="comment">#对已有的节点进行层次遍历</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                <span class="comment">#弹出队列的第一个元素</span></span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur.lchild == <span class="literal">None</span>:</span><br><span class="line">                    cur.lchild = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> cur.rchild == <span class="literal">None</span>:</span><br><span class="line">                    cur.rchild = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#如果左右子树都不为空，加入队列继续判断</span></span><br><span class="line">                    queue.append(cur.lchild)</span><br><span class="line">                    queue.append(cur.rchild)</span><br></pre></td></tr></table></figure>
<h2 id="7-2-二叉树的遍历"><a href="#7-2-二叉树的遍历" class="headerlink" title="7.2 二叉树的遍历"></a>7.2 二叉树的遍历</h2><p>树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）。那么树的两种重要的遍历模式是深度优先遍历和广度优先遍历，<strong>深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。</strong></p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>对于一颗二叉树，深度优先搜索(Depth First Search)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。</p>
<p>那么深度遍历有重要的三种方法。这三种方式常被用于访问树的节点，它们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）。我们来给出它们的详细定义，然后举例看看它们的应用。</p>
<ul>
<li>先序遍历 在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树<br>根节点-&gt;左子树-&gt;右子树</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">      <span class="string">"""递归实现先序遍历"""</span></span><br><span class="line">      <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">print</span> root.elem</span><br><span class="line">      self.preorder(root.lchild)</span><br><span class="line">      self.preorder(root.rchild)</span><br></pre></td></tr></table></figure>
<ul>
<li>中序遍历 在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树<br>左子树-&gt;根节点-&gt;右子树 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">      <span class="string">"""递归实现中序遍历"""</span></span><br><span class="line">      <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      self.inorder(root.lchild)</span><br><span class="line">      <span class="keyword">print</span> root.elem</span><br><span class="line">      self.inorder(root.rchild)</span><br></pre></td></tr></table></figure>
<ul>
<li>后序遍历 在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点<br>左子树-&gt;右子树-&gt;根节点</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">      <span class="string">"""递归实现后续遍历"""</span></span><br><span class="line">      <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      self.postorder(root.lchild)</span><br><span class="line">      self.postorder(root.rchild)</span><br><span class="line">      <span class="keyword">print</span> root.elem</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/三种遍历结果.jpg)</p>
<blockquote>
<p>课堂练习： 按照如图树的结构写出三种遍历的顺序:<br><img src="https://cdn.jsdelivr.net/gh/JoeSurmt/ImgHosting/算法与数据分析(Python" alt>/树练习.png)</p>
<p>结果：</p>
<p>先序:a b c d e f g h</p>
<p>中序:b d c e a f h g</p>
<p>后序:d e c b h g f a</p>
<p>思考：**哪两种遍历方式能够唯一的确定一颗树？？？ </p>
</blockquote>
<h3 id="广度优先遍历-层次遍历"><a href="#广度优先遍历-层次遍历" class="headerlink" title="广度优先遍历(层次遍历)"></a>广度优先遍历(层次遍历)</h3><p>从树的root开始，从上到下从从左到右遍历整个树的节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadth_travel</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""利用队列实现树的层次遍历"""</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">print</span> node.elem,</span><br><span class="line">            <span class="keyword">if</span> node.lchild != <span class="literal">None</span>:</span><br><span class="line">                queue.append(node.lchild)</span><br><span class="line">            <span class="keyword">if</span> node.rchild != <span class="literal">None</span>:</span><br><span class="line">                queue.append(node.rchild)</span><br></pre></td></tr></table></figure>

      </div>
      
        <br>
        


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-11-07T20:27:30+08:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>更新于 2019年11月7日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="../../../../tags/Python/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>Python</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="../../../../tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>算法与数据结构</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://joesurmt.github.io/2019/11/07/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(python)/&title=算法与数据分析(Python) | JoeSurmt的个站&pics=img/avatar.png&summary="
          
          >
          
            <img src="/img/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://joesurmt.github.io/2019/11/07/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(python)/&title=算法与数据分析(Python) | JoeSurmt的个站&pics=img/avatar.png&summary="
          
          >
          
            <img src="/img/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://joesurmt.github.io/2019/11/07/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(python)/&title=算法与数据分析(Python) | JoeSurmt的个站&pics=img/avatar.png&summary="
          
          >
          
            <img src="/img/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


      
      
          <div class="prev-next">
              
              
                  <section class="next">
                      <span class="art-item-right" aria-hidden="true">
                          <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                          <h4>
                              <a href="../../../10/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="prev" title="【Python】正则表达式">
                                  
                                      【Python】正则表达式
                                  
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="../../../../tags/Python/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Python</a> <a class="tag" href="../../../../tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 正则表达式</a>
                              </h6>
                          
                      </span>
                  </section>
              
          </div>
      
    </section>
  </article>



  <!-- 显示推荐文章和评论 -->



  






<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->

  <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX","TeX"],
      linebreaks: { automatic:true },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
      Macros: { href: "{}" }
    },
    messageStyle: "none"
  });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += (all[i].SourceElement().parentNode.className ? ' ' : '') + 'has-jax';
    }
  });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>




  <script>
    window.subData = {
      title: '算法与数据分析(Python)',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
      
        
          
          
            
              <section class='widget author'>
  <div class='content pure'>
    
      <div class='avatar'>
        <img class='avatar' src='../../../../img/avatar.png'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="../../../../atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:me@qiugangchao93@gmail.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/JoeSurmt"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="http://music.163.com/playlist?id=383583883&userid=43055495"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
            
              
  <section class='widget toc-wrapper'>
    
<header class='pure'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <!-- <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div> -->
  
</header>

    <div class='content pure'>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概念引入"><span class="toc-text">1. 概念引入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-算法的提出"><span class="toc-text">1.1 算法的提出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算法的概念"><span class="toc-text">算法的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法的五大特性"><span class="toc-text">算法的五大特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-算法效率衡量"><span class="toc-text">1.2 算法效率衡量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行时间反应算法效率"><span class="toc-text">执行时间反应算法效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单靠时间值绝对可信吗？"><span class="toc-text">单靠时间值绝对可信吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度与“大O记法”"><span class="toc-text">时间复杂度与“大O记法”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解“大O记法”"><span class="toc-text">如何理解“大O记法”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最坏时间复杂度"><span class="toc-text">最坏时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度的几条基本计算规则"><span class="toc-text">时间复杂度的几条基本计算规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-实际算法分析"><span class="toc-text">1.3 实际算法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-常见时间复杂度"><span class="toc-text">1.4 常见时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常见时间复杂度之间的关系"><span class="toc-text">常见时间复杂度之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Python内置类型性能分析"><span class="toc-text">1.5 Python内置类型性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#timeit模块"><span class="toc-text">timeit模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list的操作测试"><span class="toc-text">list的操作测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list内置操作的时间复杂度"><span class="toc-text">list内置操作的时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dict内置操作的时间复杂度"><span class="toc-text">dict内置操作的时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-数据结构"><span class="toc-text">1.6 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法与数据结构的区别"><span class="toc-text">算法与数据结构的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象数据类型-Abstract-Data-Type"><span class="toc-text">抽象数据类型(Abstract Data Type)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-顺序表"><span class="toc-text">2. 顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-顺序表的基本形式"><span class="toc-text">2.1 顺序表的基本形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-顺序表的结构与实现"><span class="toc-text">2.2 顺序表的结构与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序表的结构"><span class="toc-text">顺序表的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#顺序表的两种基本实现方式"><span class="toc-text">顺序表的两种基本实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素存储区替换"><span class="toc-text">元素存储区替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素存储区扩充"><span class="toc-text">元素存储区扩充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-顺序表的操作"><span class="toc-text">2.3 顺序表的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#增加元素"><span class="toc-text">增加元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除元素"><span class="toc-text">删除元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Python中的顺序表"><span class="toc-text">2.4 Python中的顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#list的基本实现技术"><span class="toc-text">list的基本实现技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-链表"><span class="toc-text">3. 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-单向链表"><span class="toc-text">3.1 单向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#节点实现"><span class="toc-text">节点实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单链表的操作"><span class="toc-text">单链表的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单链表的实现"><span class="toc-text">单链表的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表与顺序表的对比"><span class="toc-text">链表与顺序表的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-单向循环链表"><span class="toc-text">3.2 单向循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-双向链表"><span class="toc-text">3.3 双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作-1"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现-1"><span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-栈"><span class="toc-text">4.栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1栈结构实现"><span class="toc-text">4.1栈结构实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#栈的操作"><span class="toc-text">栈的操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-队列"><span class="toc-text">5. 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-队列的实现"><span class="toc-text">5.1 队列的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作-2"><span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-双端队列"><span class="toc-text">5.2 双端队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作-3"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现-2"><span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-排序与搜索"><span class="toc-text">6. 排序与搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-冒泡排序"><span class="toc-text">6.1 冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序的分析"><span class="toc-text">冒泡排序的分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序的演示"><span class="toc-text">冒泡排序的演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-选择排序"><span class="toc-text">6.2 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序分析"><span class="toc-text">选择排序分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度-1"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序演示"><span class="toc-text">选择排序演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-插入排序"><span class="toc-text">6.3 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序分析"><span class="toc-text">插入排序分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度-2"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序演示"><span class="toc-text">插入排序演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-快速排序"><span class="toc-text">6.4 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序的分析"><span class="toc-text">快速排序的分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度-3"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序演示"><span class="toc-text">快速排序演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-希尔排序"><span class="toc-text">6.5 希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序过程"><span class="toc-text">希尔排序过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序的分析"><span class="toc-text">希尔排序的分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度-4"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序演示"><span class="toc-text">希尔排序演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-归并排序"><span class="toc-text">6.6 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#归并排序的分析"><span class="toc-text">归并排序的分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度-5"><span class="toc-text">时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-常见排序算法效率比较"><span class="toc-text">6.7 常见排序算法效率比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-搜索"><span class="toc-text">6.8 搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二分法查找"><span class="toc-text">二分法查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二分法查找实现"><span class="toc-text">二分法查找实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间复杂度-6"><span class="toc-text">时间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-树与树算法"><span class="toc-text">7. 树与树算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-二叉树"><span class="toc-text">7.1 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的基本概念"><span class="toc-text">二叉树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的性质-特性"><span class="toc-text">二叉树的性质(特性)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的节点表示以及树的创建"><span class="toc-text">二叉树的节点表示以及树的创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-二叉树的遍历"><span class="toc-text">7.2 二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#深度优先遍历"><span class="toc-text">深度优先遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#广度优先遍历-层次遍历"><span class="toc-text">广度优先遍历(层次遍历)</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
            
              <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="../../../../index.html" href="../../../../index.html"
          
          
          id="........index.html">
          
            <i class="fas fa-clock fa-fw" aria-hidden="true"></i>
          
          近期文章
        </a></li>
      
        <li><a class="flat-box" title="../../../../blog/archives/" href="../../../../blog/archives/"
          
            rel="nofollow"
          
          
          id="........blogarchives">
          
            <i class="fas fa-archive fa-fw" aria-hidden="true"></i>
          
          文章归档
        </a></li>
      
        <li><a class="flat-box" title="../../../../projects/" href="../../../../projects/"
          
          
          id="........projects">
          
            <i class="fas fa-code-branch fa-fw" aria-hidden="true"></i>
          
          开源项目
        </a></li>
      
        <li><a class="flat-box" title="../../../../friends/" href="../../../../friends/"
          
            rel="nofollow"
          
          
          id="........friends">
          
            <i class="fas fa-link fa-fw" aria-hidden="true"></i>
          
          我的友链
        </a></li>
      
        <li><a class="flat-box" title="../../../../about/" href="../../../../about/"
          
            rel="nofollow"
          
          
          id="........about">
          
            <i class="fas fa-info-circle fa-fw" aria-hidden="true"></i>
          
          关于小站
        </a></li>
      
    </ul>
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
            
              

            
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="nofollow"
    
    
    href="../../../../blog/tags/"
    title="blog/tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="../../../../tags/Python/" style="font-size: 24px; color: #555">Python</a> <a href="../../../../tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 14px; color: #999">正则表达式</a> <a href="../../../../tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14px; color: #999">算法与数据结构</a>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
            
              <section class='widget list'>
  
<header class='pure'>
  <div><i class="fas fa-thumbs-up fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;强烈推荐</div>
  
</header>

  <div class='content pure'>
    <ul class="entry">
      
        <li><a class="flat-box" title="https://xaoxuu.com/wiki/hexo.sh/" href="https://xaoxuu.com/wiki/hexo.sh/"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;Hexo脚本（Mac）
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="https://xaoxuu.com/wiki/vim-cn.sh/" href="https://xaoxuu.com/wiki/vim-cn.sh/"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;图床脚本（Mac）
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="https://yasuotu.com" href="https://yasuotu.com"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;图片在线压缩
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="https://realfavicongenerator.net" href="https://realfavicongenerator.net"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;生成Favicon
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="https://mxclub.github.io/resume/" href="https://mxclub.github.io/resume/"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;简历主题
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

            
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="../../../../atom.xml"
            class="social fas fa-rss flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:me@qiugangchao93@gmail.com"
            class="social fas fa-envelope flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/JoeSurmt"
            class="social fab fa-github flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="http://music.163.com/playlist?id=383583883&amp;userid=43055495"
            class="social fas fa-headphones-alt flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>




  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["img/messi1.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["img/messi1.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  











  <script src="../../../../js/app.js"></script>


  <script src="../../../../js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





  <script>setLoadingBarProgress(100);</script>
</body>
</html>
